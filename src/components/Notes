callback is the function send as an argument to another function.
When One function referring to another one for it's finishing.

Паттерны проектирования (собесы):
- observer:
(Observer is a behavioral design pattern that lets you define a subscription mechanism to notify multiple
objects about any events that happen
to the object they’re observing.)
Parts: publisher, subscribers.
Example: по этому паттерну работает button.addEventListener (as well as onClick, onChange)

Инкапсуляция - сокрытие деталей. Мы используем только интерфейс объкта.
_key: value -> private property

Cеттеры и геттеры - для нас это просто положи и достань. Но под капотом может быть сокрыта сложная логика =>
вместо простого присвоения, у объекта пользуем сеттер

THIS
this указывает на объект, который его ВЫЗЫВАЕТ. Пример:
state.addPost() - state вызывает addPost => this будет указывать на state
state.addPost - просто указание на метод без вызова. Значит this для addPost будет тот, кто его вызвал.

BIND
Если я хочу связать контекст this с определенный объектом, я вызываю метод bind.
Продолжение примера:  Хочу связать state.addPost с объектом state =>
state.addPost.bind(state). Все, теперь, если внутри f addPost будет this, он ссылается на state.

1 create a folder for reducers
2 create reducers (profile, dialog, sidebar)
3 reducer takes state and action;
do smth with STATE and return state (do not include observer)
4 export reducers
5 now inside dispatch add each reducer.
It'll be checked every time action id dispatched;
6 call callsubscriber to rerender the tree
    7. chande if to cases
    8. Pass action creators to reducers.

REDUX
terminology
action - obj that has type
1 add reducers to store
- combineReducers()
2 initialize initial state followinf ex:

sum (a=1, b=1) {}
return a+b //
sum() => if no parameters passed, default 1 ans 1 will be used.
 the same logic is with initial state:
 const profileReducer = (state = initialState, action )

РАНДОМ
создаем let refContainer = React.createRef()
    //получает нативный DOM-элемент, т.е в ref мы храним
        //ссылки на узел DOM
       в любом месте указываем <textarea ref={refContainer}>
ассинхронный значит где-то в стороне, "сайд эффект"

PURE FUNCTION
Pure functions are for producing some output based on given inputs. A function maps input values to output values.
(идемпатентность, детерминированность) функция принимает одни данные и возвращает результат, определенный именно этими даннвми.
Если придут другие данные - результат будет другой, определенный именно ЭТИМИ даннвми.
REACT: ф функцию приходят props и возвр. JSX.(props -> functional component -> JSX).
Детерминироанная функция - она чистая , сайд эффектов (влияние глобальные стейтов, которые м измениться).
array - это объекты, .push, toUpperCase, splice - не меня.т сам объект, поэтому объект остается равен себе же.
Connect, React такие изменения не отлавливает и перерсовку не делает.
PF shouldn't include:
- api calls;
- modification of parameters;
- change DOM directly;
- change outer scope variables;

ГЛУБОКОЕ И ПОВЕРХНОСТНОЕ КОПИРОВАНИЕ
Мы редьюсером не имеем право ничего менять. Он должен пушить и менять только копию.

For example:
        switch() {
        case:
        ...
        let stateCopy = {...state}
        stateCopy.posts = {...stateCopy.posts}
        stateCopy.posts.push(newPost);
return stateCopy
} || проще запись: return {...state, posts: [...state.posts, newPost]} - буквально говорим:
"сделайт стейта такимЖ он как старый, но св-во postData : это скопированная постдата, с дабовленным новым постом
, а св-во newPostText, который примитив, просто переопределели".

ПРАВИЛА при разработке:
- иммутабельность: ф-я не должна изменять приходящие к ней данные
(e.g reducer д. брать стейт и менять action-ом копию этого стейта, оригинальный объект не меняем);
- reducers must be pure functions;
- в моем приложении я придерживаюсь концепции: 1 page - 1 reducer;


REACT-REDUX -- прослойка м-у BBL и UI
- Provider is given to “provide” the store to its child components.
- The connect() function connects a React component to a Redux store.
- connect(mstp, mdtp)(component) - создает контейнер для нашей презентационной компоненты,
чтобы она пользовалась данными стора через пропсы
- mapStateToProps - преобразует часть стейта в пропсы
- mapDispatchToProps - возвращается коллбэки, нужные нашей функции.

Классы нужны для создания однотипных объектов